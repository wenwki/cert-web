import configargparse
import os
import logging

from cert_tools import helpers
from cert_core import BlockchainType, Chain, chain_to_bitcoin_network, UnknownChainError
import bitcoin
from singleton import Singleton

PATH = os.path.dirname(os.path.abspath(__file__))
WORK_PATH = os.path.join(PATH, 'work')

def configure_logger():
    # Configure logging settings; create console handler and set level to info
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    handler.setLevel(logging.INFO)
    formatter = logging.Formatter("%(levelname)s - %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)

class Config(metaclass=Singleton): 
    def add_arguments(self, p):
        p.add('-c', '--config', required=False,
                    is_config_file=True, help='config file path')
        p.add_argument('--data_dir', type=str, help='where data files are located')
        p.add_argument('--db_url', default='mongodb://localhost:27017/',
                    type=str, help='url to database')
        # for tools
        p.add_argument('-d', '--domain_name_prefix', type=str, required=True,
                    help='domain name prefix, e.g. https://www.blockcerts.org or localhost:8000')
        p.add_argument('-u', '--issuer_url', type=str,
                    help='the issuer\'s main URL address')
        p.add_argument('-n', '--issuer_name', type=str, help='the issuer\'s name')
        p.add_argument('-e', '--issuer_email', type=str,
                    help='the issuer\'s email')
        p.add_argument('-d', '--issuer_id_path', type=str, required=True,
                    help='the issuer\'s publicly accessible identification file; i.e. URL of the file generated by this tool, which will be concatenated with domain_name_prefix')
        p.add_argument('-r', '--revocation_list_path', type=str, required=True,
                    help='URI of the Revocation List used for marking revocation, which will be concatenated with domain_name_prefix')
        p.add_argument('-k', '--public_key_created', type=str,
                    help='ISO8601-formatted date the issuer public key should be considered active')

        p.add_argument('--issuer_certs_url', type=str,
                    help='issuer certificates URL')
        p.add_argument('--certificate_description', type=str,
                    help='the display description of the certificate')
        p.add_argument('--certificate_title', required=True,
                    type=str, help='the title of the certificate')
        p.add_argument('--hash_emails', action='store_true',
                    help='whether to hash emails in the certificate')
        p.add_argument('--badge_id', type=str, help='badge id')
        p.add_argument('--from_date', type=str, help='from date')
        p.add_argument('--to_date', type=str, help='to date')
        p.add_argument('--issuer_signature_lines', action=helpers.make_action('issuer_signature_lines'),
                    help='issuer signature lines')
        p.add_argument('--additional_global_fields', action=helpers.make_action('global_fields'),
                    help='additional global fields')
        p.add_argument('--additional_per_recipient_fields', action=helpers.make_action('per_recipient_fields'),
                    help='additional per-recipient fields')
        p.add_argument('--display_html', type=str, help='html content to display')

        # for the issuer
        p.add_argument('-p', '--public_key', type=str, required=True, env_var='PUBLIC_KEY',
                    help='public key of issuer, which will be used to sign the certificate and this is used as the address to issue')
        p.add_argument('--usb_name', required=True,
                    help='usb path to key_file', env_var='USB_NAME')
        p.add_argument('--private_key_file', required=True,
                    help='name of file on USB containing private key', env_var='KEY_FILE')
        p.add_argument('--work_dir', default=WORK_PATH,
                    help='Default path to work directory, storing intermediate outputs. This gets deleted in between runs.', env_var='WORK_DIR')
        p.add_argument('--max_retry', default=10, type=int,
                    help='Maximum attempts to retry transaction on failure', env_var='MAX_RETRY')
        p.add_argument('--chain', default='bitcoin_regtest',
                    help=('Which chain to use. Default is bitcoin_regtest (which is how the docker container is configured). Other options are '
                            'bitcoin_testnet bitcoin_mainnet, mockchain, ethereum_mainnet, ethereum_ropsten'), env_var='CHAIN')

        p.add_argument('--safe_mode', dest='safe_mode', default=True, action='store_true',
                    help='Used to make sure your private key is not plugged in with the wifi.', env_var='SAFE_MODE')
        p.add_argument('--no_safe_mode', dest='safe_mode', default=False, action='store_false',
                    help='Turns off safe mode. Only change this option for testing or unit testing.', env_var='NO_SAFE_MODE')
        # bitcoin arguments
        p.add_argument('--dust_threshold', default=0.0000275, type=float,
                    help='blockchain dust threshold (in BTC) -- below this 1/3 is fees.', env_var='DUST_THRESHOLD')
        p.add_argument('--tx_fee', default=0.0006, type=float,
                    help='recommended tx fee (in BTC) for inclusion in next block. http://bitcoinexchangerate.org/fees', env_var='TX_FEE')
        p.add_argument('--batch_size', default=10, type=int,
                    help='Certificate batch size', env_var='BATCH_SIZE')
        p.add_argument('--satoshi_per_byte', default=250,
                    type=int, help='Satoshi per byte', env_var='SATOSHI_PER_BYTE')
        p.add_argument('--bitcoind', dest='bitcoind', default=False, action='store_true',
                    help='Use bitcoind connectors.', env_var='BITCOIND')
        p.add_argument('--no_bitcoind', dest='bitcoind', default=True, action='store_false',
                    help='Default; do not use bitcoind connectors; use APIs instead', env_var='NO_BITCOIND')
        # ethereum arguments
        p.add_argument('--gas_price', default=20000000000, type=int,
                    help='decide the price per gas spent (in wei (smallest ETH unit))', env_var='GAS_PRICE')
        p.add_argument('--gas_limit', default=25000, type=int,
                    help='decide on the maximum spendable gas. gas_limit < 25000 might not be sufficient', env_var='GAS_LIMIT')
        p.add_argument('--api_token', default=None, type=str,
                    help='the API token of the blockchain broadcaster you are using. Currently Etherscan only supported.', env_var='API_TOKEN')
        p.add_argument('--blockcypher_api_token', default=None, type=str,
                    help='the API token of the blockcypher broadcaster', env_var='BLOCKCYPHER_API_TOKEN')


    def initialize(self):
        cwd = os.getcwd()
        p = configargparse.getArgumentParser(
            default_config_files=[os.path.join(cwd, 'conf.ini')])
            
        self.add_arguments(p)
        args, _ = p.parse_known_args()

        # overwrite with enum
        args.chain = Chain.parse_from_chain(args.chain)

        # ensure it's a supported chain
        if args.chain.blockchain_type != BlockchainType.bitcoin and \
                args.chain.blockchain_type != BlockchainType.ethereum and \
                args.chain.blockchain_type != BlockchainType.mock:
            raise UnknownChainError(args.chain.name)

        logging.info('This run will try to issue on the %s chain',
                    args.chain.name)

        if args.chain.blockchain_type == BlockchainType.bitcoin:
            bitcoin_chain_for_python_bitcoinlib = args.chain
            if args.chain == Chain.bitcoin_regtest:
                bitcoin_chain_for_python_bitcoinlib = Chain.bitcoin_regtest
            bitcoin.SelectParams(chain_to_bitcoin_network(
                bitcoin_chain_for_python_bitcoinlib))

        self.config = args
        return self

    def get(self):
        return self.config
